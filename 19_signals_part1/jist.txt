Theory0:
What is a signal?
=====================================================

A signal is an event generated by the UNIX and Linux systems in response to some condition, upon receipt of which a process may in turn take some action.

Signal can be thought of as software interrupt

Who can send signals?
========================================================
----> Kernel to Process

----> Process to another Process

----> Process to itself

What happens when the process receives a signal which it is not catching?
=====================================================

------>  the process will be terminated immediately

------>  a core dump file is created.

------>   This file, called core and placed in the current directory

------>   is an image of the process that can be useful in debugging

What are the types of signals in Linux?
=====================================================

Two types:
1. Maskable
2. Non Maskable

Maskable signals or interrupts in Linux are those signals which can be changed or ignored by the user.
E.g. ctrl+c , ctrl+\

Non-Maskable signals or interrupts are those interrupts which cannot be changed or ignored by the user. For example, Ctrl+Z.
E.g. ctrl+z

Command to find out the list of signals in Linux?
=====================================================

kill -l

Meaning of each signals
======================================================================
SIGHUP          ---->   If a process is being run from terminal and that terminal suddenly goes away then the process receives this signal. “HUP” is short for “hang up” and refers to hanging up the telephone in the days of telephone modems

SIGINT          ---->   The process was “interrupted”. This happens when you press Control+C on the controlling terminal.

SIGQUIT         ---->   Control+\

SIGILL          ---->   Illegal instruction. The program contained some machine code the CPU can't understand.

SIGTRAP         ---->   This signal is used mainly from within debuggers and program tracers

SIGABRT         ---->   The program called the abort() function. This is an emergency stop

SIGBUS          ---->   An attempt was made to access memory incorrectly. This can be caused by alignment errors in memory access etc.

SIGFPE          ---->   A floating point exception happened in the program.

SIGKILL         ---->   The process was explicitly killed by somebody wielding the kill program.

SIGUSR1         ---->   Left for the programmers to do whatever they want

SIGSEGV         ---->   An attempt was made to access memory not allocated to the process. This is often caused by reading off the end of arrays etc.

SIGUSR2         ---->   Left for the programmers to do whatever they want.

SIGPIPE         ---->   If a process is producing output that is being fed into another process that consume it via a pipe (“producer | consumer”) and the consumer dies then the producer is sent this signal.

SIGALRM         ---->   A process can request a “wake up call” from the operating system at some time in the future by calling the alarm() function. When that time comes round the wake up call consists of this signal.

SIGTERM         ---->   The process was explicitly killed by somebody wielding the kill program.

SIGSTKFLT       ---->   Stack fault on coprocessor

SIGCHLD         ---->   The process had previously created one or more child processes with the fork() function. One or more of these processes has since died.

SIGCONT         ---->   (To be read in conjunction with SIGSTOP.) If a process has been paused by sending it SIGSTOP then sending SIGCONT to the process wakes it up again (“continues” it).

SIGSTOP         ---->   (To be read in conjunction with SIGCONT.)If a process is sent SIGSTOP it is paused by the operating system. All its state is preserved ready for it to be restarted (by SIGCONT) but it doesn't get any more CPU cycles until then.

SIGTSTP         ---->   Essentially the same as SIGSTOP. This is the signal sent when the user hits Control+Z on the terminal. (SIGTSTP is short for “terminal stop”) The only difference between SIGTSTP and SIGSTOP is that pausing is only the default action for SIGTSTP but is the required action for SIGSTOP. The process can opt to handle SIGTSTP differently but gets no choice regarding SIGSTOP

SIGTTIN         ---->   The operating system sends this signal to a backgrounded process when it tries to read input from its terminal. The typical response is to pause (as per SIGSTOP and SIFTSTP) and wait for the SIGCONT that arrives when the process is brought back to the foreground

SIGTTOU         ---->   The operating system sends this signal to a backgrounded process when it tries to write output to its terminal. The typical response is as per SIGTTIN.

SIGURG          ---->   The operating system sends this signal to a process using a network connection when “urgent” out of band data is sent to it.

SIGXCPU         ---->   The operating system sends this signal to a process that has exceeded its CPU limit. You can cancel any CPU limit with the shell command “ulimit -t unlimited” prior to running make though it is more likely that something has gone wrong if you reach the CPU limit in make.

SIGXFSZ         ----->  The operating system sends this signal to a process that has tried to create a file above the file size limit. You can cancel any file size limit with the shell command “ulimit -f unlimited” prior to running make though it is more likely that something has gone wrong if you reach the file size limit in make.

SIGVTALRM       ----->  This is very similar to SIGALRM, but while SIGALRM is sent after a certain amount of real time has passed, SIGVTALRM is sent after a certain amount of time has been spent running the process.

SIGPROF         ----->  This is also very similar to SIGALRM and SIGVTALRM, but while SIGALRM is sent after a certain amount of real time has passed, SIGPROF is sent after a certain amount of time has been spent running the process and running system code on behalf of the process.

SIGWINCH        ----->  (Mostly unused these days.) A process used to be sent this signal when one of its windows was resized

SIGIO           ----->  (Also known as SIGPOLL.) A process can arrange to have this signal sent to it when there is some input ready for it to process or an output channel     has become ready for writing.

SIGPWR          ----->  A signal sent to processes by a power management service to indicate that power has switched to a short term emergency power supply. The process (especially long-running daemons) may care to shut down cleanlt before the emergency power fails

SIGSYS          ----->  Unused

How to send Signals?
=====================================================
Sending signals from Keyboard:

----->  When you press CTRL+C key, a SIGINT  is sent which default action is to terminate the process

-----> When you press CTRL+\ key, a SIGQUIT is sent which default action is to terminate the process dumping core

-----> When you press CTRL+Z key, a SIGSTOP signal is sent that suspends the program

Other common method is to use the kill command
kill -signal pid
killall -signal binary
The difference between kill and killall is that kill only sends signals to process identified by their pid, killall sends the signal to all process of a given name.

How can I learn more about signals?
====================================

The linux man pages discusses signal system calls in section 2. 
There is also a longer article in section 7
man -s7 signal

Why Signals are Needed
==========================

With Signals, a process can asynchronously receive information about certain events or condition.

A process can trap or subscribe to a signal; when this occurs, the process will asynchronously be notified of the fact by the OS, and will then run the code of a function in response: a signal handler.

Examples:

1. The developer wants to perform a common task: set up a timer and have it expire in, say, 1.5 seconds from now. How will the OS inform the process that the timer has expired?

2. A process has an inadvertent defect (a bug); it makes an invalid memory access. subsystem (well, technically, the MMU and the OS) determines it must be killed. How exactly will it be killed?

3. Linux's asynchronous IO (AIO) framework, and many other such scenarios.

All of these example scenarios are serviced by the same mechanism: signals.

Theory1:
===================================
Introduction
===================================

Now, lets consider a situation where you use system() better. You call all programs with absolute path and everything, but even that is not enough.

You must also consider injection attacks which is when the attacker can inject code that will run.

If we were to run this program, it does mostly what you expect:

Ok, now consider if we were to provide input that doesn't fit this model. What if we were to provide shell commands as input.

./inject_system 
What input do you want to 'cat' (choose from below)
input > ;echo
Executing: /bin/cat ./;echo
/bin/cat: ./: Is a directory

The input we provided was ";echo" the semi-colon closes off a bash command alowing a new one to start. Notice that there is an extra new line printed, that was the echo printing. Now, can we get this program to run something more interesting?

We still have the cat program we wrote that prints "Goodbye World" and the PATH is set up to look in the local directory.

Theory2:
Two attacks down, moving onto the third. Let's now assume that the programmer has wised up to the two previous attacks. Now we are using full paths to executables and we are scrubbing the input to remove any potential bash commands prior to execution.

Consider what happens when we increase the size of the input selection. To do this programatically, I'm going to use a small trick of the python programming language to print a bunch of 'A's.

$ python -c "print 'A'*10"
AAAAAAAAAA
$ python -c "print 'A'*20"
AAAAAAAAAAAAAAAAAAAA
$ python -c "print 'A'*30"
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
$ python -c "print 'A'*40"
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
$ python -c "print 'A'*50"
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

I'm using this to produce strings of varying length, length 10, 20, 30, 40, and 50. Those strings can be sent to the target program using a pipe. 

python -c "print 'A'*10" | ./overflow_system

Something changes at when the input string is 50 bytes long. We overflow the buffer for the input. Recall that the input buffer is only 40 bytes and size, and it is placed adjacent to the cmd buffer:

char cmd[1024] = "/bin/cat ./"; //will append to this string

char input[40];

When the input buffer overflows, we begin to write 'A's to cmd which replaces "/bin/cat". Finally, we concatenate cmd with input, resulting in a long string of 'A's for the command being executed by system(). We can see this from the error output

How do we leverage this error to pwn this program? The program is trying to execute a command that is "AAA…" and we can control the PATH. Let's create such a program named "AAA…" Rather than writing a new program, we can use sym-linking.

ln -s cat AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
aviv@saddleback: demo $ ./AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
Goodbye World

export PATH=.:$PATH

How do we fix overflow bugs? The most direct way is to always bound checks on strings. For example, always use strncp() or strncat(), but that is even sometimes not sufficient. In the end, it requires good programmers who understand security and can identify bad programming practices. This is just a small set of examples of bad programs.

Theory3:
killall -SIGSEGV ./1

explore some of the more esoteric signals and see similar results occur when the program terminates

killall -SIGPWR ./1

killall -SIGSTOP ./1

If we were to run jobs, we can see that ./1 is stopped in the background. This is the same as typing Ctrl-z in the terminal.

killall -SIGCONT ./1

And, after we run jobs, the loop program is running in the background:

The Ctrl-c from the terminal actually generates the SIGINT signal, which stands for "interrupt" because a Ctrl-c initiates an interrupt of the foreground process, which by default terminates the process.

killall -SIGINT ./1

We will first start the process in the background 

Then send it a signal from the shell process by using the kill command.

>./program &
My pid is 403
...
>kill -SIGSTOP 403
>kill -SIGCONT 403

Can I pause my child?
=======================

Yes ! You can temporarily pause a running process by sending it a SIGSTOP signal. If it succeeds it will freeze a process; i.e. the process will not be allocated any more CPU time.

To allow a process to resume execution send it the SIGCONT signal.

Theory4:
How do I kill/stop/suspend my child from C?
============================================

In C, send a signal to the child using kill POSIX call,

Signals are also a key means for inter-process communication. 
One process can send a signal to another indicating that an action should be taken. 

To send a signal to a particular process, we use the kill() system call.
int kill(pid_t pid, int signum);

kill(child, SIGUSR1); // Send a user-defined signal
kill(child, SIGSTOP); // Stop the child process (the child cannot prevent this)
kill(child, SIGTERM); // Terminate the child process (the child can prevent this)
kill(child, SIGINT); // Equivalent to CTRL-C (by default closes the process)

How to handle Signals?
=======================================================

The primary system call for signal handling is signal()

int main()
{
        signal(SIGPWR, powerFailureHandler);
        .......
}

void powerFailureHandler(int signum)
{
        //Saves states to restore later
        .......
}

The first line in main() establishes a handler for the SIGPWR signals.

Arguments:
int signal(int signum, void (*handler)(int))
first argument: signal number, such as SIGSTOP or SIGINT
second argument: a function pointer type which points to the signal handler.

Theory5:
the second argument to signal() is a function pointer, a reference to a function to call. This tells the operating system that whenever this signal is sent to this process, run this function as the signal handler.

Also, the execution of the signal handler is asynchronous, which means the current state of the program will be paused while the signal handler executes, and then execution will resume from the pause point, much like context switching.

Theory6:
What is a process's signal disposition?
===========================================

For each process, each signal has a disposition which means what action will occur when a signal is delivered to the process.

For example, the default disposition SIGINT is to terminate it.

The signal disposition can be changed by calling signal() or sigaction()

The default disposition for signals can be to
	ignore the signal
	stop the process,
	continue a stopped process
	terminate the process
	or terminate the process and also dump a 'core' file

Note a core file is a representation of the processes' memory state that can be inspected using a debugger.

---
more details are avilable at [ man 7 signal ]
---

Theory7:
And if we run this program, we see that, yes, it Ctrl-c is ineffective and we have to use Ctrl-\ to quit the program:
But, it would seem like a pain to always have to write the silly little ignore function that does nothing, and so, when there is a need, there is a way.

The signal.h header defines a set of actions that can be used in place of the handler:

SIG_IGN : Ignore the signal
SIG_DFL : Replace the current signal handler with the default handler

Theory8:
What happens when forking?
=============================

The child process inherits a copy of the parent's signal dispositions. In other words, if you have installed a SIGINT handler before forking, then the child process will also call the handler if a SIGINT is delivered to the child.

Theory9:
The program first initiates handler_1() as the signal handler for SIGINT. After the first Ctrl-c, in the signal handler, the handler is changed to handler_2(), and after the second Ctrl-c, it is change again to handler_3() from handler_2(). Finally, in handler_3() the default signal handler is reestablished, which is to terminate on SIGINT

Theory10:
The two signals that can never be ignored or handled are: SIGKILL and SIGSTOP.
